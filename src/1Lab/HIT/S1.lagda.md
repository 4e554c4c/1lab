```
open import 1Lab.Data.Bool
open import 1Lab.Univalence
open import 1Lab.Path.Groupoid
open import 1Lab.Path
open import 1Lab.Type

module 1Lab.HIT.S1 where
```

# The Circle

Since the “intended interpretation” of HoTT is in a
$(\infty,1)$-category of “good spaces”, it makes sense that HoTT has
facilities for describing spaces. These are the _higher inductive
types_, one of which is the **circle**:

```
data S¹ : Type where
  base : S¹
  loop : base ≡ base
```

Diagramatically, we can picture the circle as being the
$\infty$-groupoid generated by the following diagram:

~~~{.quiver}
\begin{tikzpicture}
\node[draw,circle,label=below:{$\mathrm{base}$},fill,outer sep=0.1cm, inner sep=0pt, minimum size=0.1cm] (a0) at (0, -1) {};
\draw[->] (0, 0) circle (1cm);
\node[] (loop) at (0, 0) {$\mathrm{loop}\ i$};
\end{tikzpicture}
~~~

In type theory with K, the circle is exactly the same type as
`⊤`{.Agda}. However, with `univalence`{.Agda ident=ua}, it can be shown
that the circle has two different paths:

<!--
```
_ = ⊤
```
-->

```
möbius : S¹ → Type
möbius base = Bool
möbius (loop i) = ua (not , isEquiv-not) i
```

When pattern matching on the crcle, we are asked to provide a basepoint
`b` and a path `l : b ≡ b`, as can be seen in the definition above. To
make it clearer, we can also define a recursion principle: 

```
S¹-rec : {ℓ : _} {A : Type ℓ} (b : A) (l : b ≡ b) → S¹ → A
S¹-rec b l base = b
S¹-rec b l (loop i) = l i
```

Using `möbius`{.Agda}, it can be shown that the `loop`{.Agda} is not
`refl`{.Agda}:

```
parity : base ≡ base → Bool
parity l = subst möbius l true

_ : parity refl ≡ true
_ = refl

_ : parity loop ≡ false
_ = refl

refl≠loop : refl ≡ loop → ⊥
refl≠loop path = true≠false (ap parity path)
```

The circle is also useful as a source of counterexamples. By
`S¹-elim'`{.Agda}, we can prove that there is an inhabitant of `(x : S¹)
→ x ≡ x` which is not constantly `refl`{.Agda}

```
S¹-elim : {ℓ : _} {P : S¹ → Type ℓ}
        → (pb : P base)
        → PathP (λ i → P (loop i)) pb pb
        → (x : S¹) → P x
S¹-elim pb pl base = pb
S¹-elim pb pl (loop i) = pl i

S¹-elim' : {ℓ : _} {P : S¹ → Type ℓ} (pb : P base)
         → subst P loop pb ≡ pb
         → (x : S¹) → P x
S¹-elim' {P = P} pb pl =
  S¹-elim pb (transport (λ i → PathP≡Path (λ i → P (loop i)) pb pb (~ i)) pl)

always-loop : (x : S¹) → x ≡ x
always-loop = S¹-elim' loop (subst-path-both _ _ ∙ lemma)
  where
    lemma = sym loop ∙ loop ∙ loop   ≡⟨ ∙-assoc _ _ _ ⟩
            (sym loop ∙ loop) ∙ loop ≡⟨ ap₂ _∙_ (∙-inv-l _) refl ⟩
            refl              ∙ loop ≡⟨ ∙-id-left _ ⟩
            loop                     ∎ 
```