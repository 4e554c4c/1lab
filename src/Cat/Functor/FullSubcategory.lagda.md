```agda
open import Cat.Instances.Functor
open import Cat.Functor.Base
open import Cat.Univalent
open import Cat.Prelude

module Cat.Functor.FullSubcategory {o h} {C : Precategory o h} where
```

<!--
```agda
import Cat.Reasoning C as C
open Precategory
private variable
  ℓ : Level
```
-->

# Full subcategories

A **full subcategory** $\ca{D}$ of some larger category $\ca{C}$ is the
category generated by some [predicate] $P$ on the objects of of
$\ca{C}$: You keep only those objects for which $P$ holds, and all the
morphisms between them. An example is the category of abelian groups, as
a full subcategory of groups: being abelian is a proposition (there's
"at most one way for a group to be abelian").

[predicate]: 1Lab.HLevel.html#isProp

We can interpret full subcategories, by analogy, as being the "induced
subgraphs" of the categorical world: Keep only some of the vertices
(objects), but all of the arrows (arrows) between them.

```agda
Restrict : (P : C.Ob → Type ℓ) → (∀ x → isProp (P x))
         → Precategory (o ⊔ ℓ) h
Restrict P pprop .Ob = Σ[ c ∈ C.Ob ] (P c)
Restrict P pprop .Hom (A , _) (B , _) = C.Hom A B
Restrict P pprop .Hom-set _ _ = C.Hom-set _ _
Restrict P pprop .id    = C.id
Restrict P pprop ._∘_   = C._∘_
Restrict P pprop .idr   = C.idr
Restrict P pprop .idl   = C.idl
Restrict P pprop .assoc = C.assoc
```

A very important property of full subcategories (`Restrict`{.Agda}ions)
is that _any full subcategory of a univalent category is univalent_. The
argument is roughly as follows: Since $\ca{C}$ is univalent, an
isomorphism $A \cong B$ gives us a path $A \equiv B$, so in particular
if we know $A \cong B$ and $P(A)$, then we have $P(B)$. But, since the
morphisms in the full subcategory coincide with those of $\ca{C}$, any
iso in the subcategory is an iso in $\ca{C}$, thus a path!

```agda
module _ (P : C.Ob → Type ℓ) (pprop : ∀ x → isProp (P x)) 
  where
  import Cat.Reasoning (Restrict P pprop) as R
```

We begin by translating between isomorphisms in the subcategory (called
$\ca{R}$ here) and in $\ca{C}$, which can be done by destructuring and
reassembling:

```agda
  isoSub→isoSuper : ∀ {A B : Σ P} → (A R.≅ B) → (A .fst C.≅ B .fst)
  isoSub→isoSuper x = C.makeIso x.to x.from x.invˡ x.invʳ
    where module x = R._≅_ x

  isoSuper→isoSub : ∀ {A B : Σ P} → (A .fst C.≅ B .fst) → (A R.≅ B) 
  isoSuper→isoSub y = R.makeIso y.to y.from y.invˡ y.invʳ
    where module y = C._≅_ y
```

We then prove that object-isomorphism pairs in the subcategory (i.e.
inhabitants of $\sum_{B : \ca{R}} (A \cong B)$) coincide with those in
the supercategory; Hence, since $\ca{C}$ is by assumption univalent, so
is $\ca{R}$.

```agda
  isCategory-Restrict : isCategory C → isCategory (Restrict P pprop)
  isCategory-Restrict univ (A , p) = isHLevel≃ 0 equiv (univ A)
    where
      to : (Σ[ B ∈ C.Ob ] A C.≅ B) → (Σ[ B ∈ R.Ob ] (A , p) R.≅ B)
      to (B , isom) = (B , subst P A≡B p) , isoSuper→isoSub isom
        where A≡B = isoToPath C univ isom

      from : (Σ[ B ∈ R.Ob ] (A , p) R.≅ B) → (Σ[ B ∈ C.Ob ] A C.≅ B)
      from ((B , _) , isom) = B , isoSub→isoSuper isom

      rinv : isRightInverse from to
      rinv (x , i) = Σ-PathP (Σ≡Prop pprop refl) (R.≅-PathP _ _ refl refl)

      linv : isLeftInverse from to
      linv (x , i) = Σ-PathP refl (C.≅-PathP _ _ refl refl)

      equiv : (Σ[ B ∈ C.Ob ] A C.≅ B) ≃ (Σ[ B ∈ R.Ob ] (A , p) R.≅ B)
      equiv = to , isIso→isEquiv (iso from rinv linv)
```

## From full inclusions

There is another way of representing full subcategories: By giving a
_full inclusion_, i.e. a [fully faithful] functor $F : \ca{D} \to
\ca{C}$. Each full inclusion canonically determines a full subcategory
of $\ca{C}$, namely that consisting of the objects in $\ca{C}$ merely in
the image of $F$.

[fully faithful]: Cat.Functor.Base#ff-functors

```agda
module _ {o' h'} {D : Precategory o' h'} {F : Functor D C} (ff : isFf F) where
  open Functor F

  FullInclusion→FullSubcat : Precategory _ _
  FullInclusion→FullSubcat = 
    Restrict (λ x → ∃[ d ∈ Ob D ] (F₀ d C.≅ x)) λ _ → squash
```

This canonical full subcategory is weakly equivalent to $\ca{D}$,
meaning that it admits a fully faithful, [essentially surjective]
functor from $\ca{D}$. This functor is actually just $F$ again:

[essentially surjective]: Cat.Functor.Base.html#essential-fibres

```agda
  Ff-domain→FullSubcat : Functor D FullInclusion→FullSubcat
  Ff-domain→FullSubcat .Functor.F₀ x = F₀ x , inc (x , C.idIso)
  Ff-domain→FullSubcat .Functor.F₁ = F₁
  Ff-domain→FullSubcat .Functor.F-id = F-id
  Ff-domain→FullSubcat .Functor.F-∘ = F-∘

  isFf-domain→FullSubcat : isFf Ff-domain→FullSubcat
  isFf-domain→FullSubcat = ff

  isEso-domain→FullSubcat : isEso Ff-domain→FullSubcat
  isEso-domain→FullSubcat (y , o) = 
    ∥-∥-map (λ (preimg , isom) → preimg , isoSuper→isoSub _ (λ _ → squash) isom) o
```

Up to weak equivalence, admitting a full inclusion is equivalent to
being a full subcategory: Every full subcategory admits a full
inclusion, given on objects by projecting the first component and on
morphisms by the identity function.

```agda
module _ {P : C.Ob → Type ℓ} {pprop : ∀ x → isProp (P x)} where
  ForgetFullSubcat : Functor (Restrict P pprop) C
  ForgetFullSubcat .Functor.F₀ = fst
  ForgetFullSubcat .Functor.F₁ f = f
  ForgetFullSubcat .Functor.F-id = refl
  ForgetFullSubcat .Functor.F-∘ f g i = f C.∘ g

  isFf-ForgetFullSubcat : isFf ForgetFullSubcat
  isFf-ForgetFullSubcat = idEquiv
```