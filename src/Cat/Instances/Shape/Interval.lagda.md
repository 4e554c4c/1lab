```agda
open import Cat.Diagram.Terminal
open import Cat.Diagram.Product
open import Cat.FinitelyComplete
open import Cat.Prelude
open import Cat.Thin

open import Data.Bool

module Cat.Instances.Shape.Interval where
```

<!--
```agda
open Terminal
open Product
open is-product
```
-->

# Interval category

The interval category is the category with two points, called (as a form
of endearment) $0$ and $1$, and a single arrow between them.
Correspondingly, in shorthand this category is referred to as $\intcat$.
Since it has a single (non-trivial) arrow, it is a [preorder]; In fact,
it is the preorder generated by the type of [booleans] and the natural
ordering on them, with $\bot \le \top$.

[preorder]: Cat.Thin.html
[booleans]: Data.Bool.html

```agda
open Precategory

Bool-poset : Poset lzero lzero
Bool-poset = make-poset {R = R} Rrefl Rtrans Rantisym Rprop where
  R : Bool → Bool → Type
  R false false = ⊤
  R false true  = ⊤
  R true  false = ⊥
  R true  true  = ⊤
```

**Note**: We define the relation by recursion, rather than by induction,
to avoid the issues with computational behaviour with indexed inductive
types in Cubical Agda. The interval category is the category underlying
the poset of booleans:

<!--
```agda
  Rrefl : ∀ {x} → R x x
  Rrefl {false} = tt
  Rrefl {true} = tt

  Rtrans : ∀ {x y z} → R x y → R y z → R x z
  Rtrans {false} {false} {false} tt tt = tt
  Rtrans {false} {false} {true}  tt tt = tt
  Rtrans {false} {true}  {false} tt ()
  Rtrans {false} {true}  {true}  tt tt = tt
  Rtrans {true}  {false} {false} () tt
  Rtrans {true}  {false} {true}  () tt
  Rtrans {true}  {true}  {false} tt ()
  Rtrans {true}  {true}  {true}  tt tt = tt

  Rantisym : ∀ {x y} → R x y → R y x → x ≡ y
  Rantisym {false} {false} tt tt = refl
  Rantisym {false} {true}  tt ()
  Rantisym {true}  {false} () tt
  Rantisym {true}  {true}  tt tt = refl

  Rprop : ∀ {x y} (p q : R x y) → p ≡ q
  Rprop {false} {false} tt tt = refl
  Rprop {false} {true}  tt tt = refl
  Rprop {true}  {false} () ()
  Rprop {true}  {true}  tt tt = refl
```
-->

```agda
0≤1 : Precategory lzero lzero
0≤1 = Bool-poset .Poset.underlying
```

## Meets

Note that the category $\intcat$ is finitely complete (i.e. it is
bounded, and has binary meets for every pair of elements): The top
element is $\top$ (go figure), and meets are given by the boolean "and"
function".

```agda
0≤1-top : Terminal 0≤1
0≤1-top .top = true

0≤1-top .has⊤ false .centre = tt
0≤1-top .has⊤ false .paths tt = refl

0≤1-top .has⊤ true  .centre = tt
0≤1-top .has⊤ true  .paths tt = refl

0≤1-products : ∀ A B → Product 0≤1 A B
0≤1-products A B .apex = and A B
```

<details>
<summary>
A ridiculous amount of trivial pattern matching is needed to establish
that this cone is universal, but fortunately, we can appeal to thinness
to establish commutativity and uniqueness.
</summary>

```agda
0≤1-products false false .π₁ = tt
0≤1-products false true  .π₁ = tt
0≤1-products true  false .π₁ = tt
0≤1-products true  true  .π₁ = tt

0≤1-products false false .π₂ = tt
0≤1-products false true  .π₂ = tt
0≤1-products true  false .π₂ = tt
0≤1-products true  true  .π₂ = tt

0≤1-products A B .has-is-product .⟨_,_⟩ = meet _ _ _ where
  meet : ∀ A B Q (p : Hom 0≤1 Q A) (q : Hom 0≤1 Q B) → Hom 0≤1 Q (and A B)
  meet false false false tt tt = tt
  meet false false true  () ()
  meet false true  false tt tt = tt
  meet false true  true  () tt
  meet true  false false tt tt = tt
  meet true  false true  tt ()
  meet true  true  false tt tt = tt
  meet true  true  true  tt tt = tt
```

</details>

```agda
0≤1-products A B .has-is-product .π₁∘factor = 
  Bool-poset .Poset.Hom-is-prop _ _ _ _
0≤1-products A B .has-is-product .π₂∘factor = 
  Bool-poset .Poset.Hom-is-prop _ _ _ _
0≤1-products A B .has-is-product .unique _ _ _ = 
  Bool-poset .Poset.Hom-is-prop _ _ _ _

0≤1-finitely-complete : Finitely-complete 0≤1
0≤1-finitely-complete = 
  with-top-and-meets 0≤1 (Bool-poset .Poset.has-is-thin) 
  0≤1-top 0≤1-products
```
